# Улучшения SQL схемы для системы управления картриджами

## Основные улучшения

### 1. **Объединение таблиц `requests` и `request_items`**
**Было:** 2 отдельные таблицы с связью один-ко-многим
**Стало:** Одна таблица с JSON полем `items_json`

**Преимущества:**
- Уменьшение количества таблиц с 7 до 6
- Упрощение запросов (не нужны JOIN'ы)
- Атомарность операций с заявкой
- Лучшая производительность для чтения

**Пример использования:**
```sql
-- Создание заявки с элементами
INSERT INTO requests (items_json) VALUES (
  json_array(
    json_object('cartridge_type_id', 1, 'quantity', 2),
    json_object('cartridge_type_id', 2, 'quantity', 1)
  )
);

-- Получение элементов заявки
SELECT json_extract(value, '$.quantity') as quantity
FROM requests r
CROSS JOIN json_each(r.items_json)
WHERE r.id = 1;
```

### 2. **Упрощение таблицы `logs`**
**Было:** Отдельные поля для `from_status`, `to_status`, `note`
**Стало:** Одно поле `details_json` для всех деталей

**Преимущества:**
- Гибкость в хранении различных типов логов
- Возможность добавления новых полей без изменения схемы
- Более компактная структура

### 3. **Добавление значений по умолчанию**
- `role` по умолчанию `'branch_user'`
- `priority` по умолчанию `'normal'`
- `status` по умолчанию `'new'`
- `items_json` по умолчанию `'[]'`

### 4. **Улучшенные ограничения целостности**
- `CHECK(quantity >= 0)` для предотвращения отрицательных остатков
- `CHECK(json_valid(items_json))` для валидации JSON
- `ON DELETE CASCADE` для автоматической очистки связанных данных

### 5. **Автоматизация через триггеры**
- Автоматическое создание записей в `stock_items` при добавлении филиалов/картриджей
- Автоматическое логирование изменений статуса
- Автоматическое обновление `completed_at` при завершении заявки

### 6. **Представления для упрощения запросов**
- `v_active_requests` - активные заявки с информацией о филиалах и пользователях
- `v_stock_summary` - сводка по складу с статусами
- `v_request_availability` - проверка доступности картриджей
- `v_request_stats` - статистика по заявкам
- `v_sla_monitoring` - мониторинг SLA

### 7. **Индексы для оптимизации**
- Индексы по часто используемым полям
- Составные индексы для сложных запросов

## Сравнение размеров

| Компонент | Исходная схема | Улучшенная схема | Экономия |
|-----------|----------------|------------------|----------|
| Таблицы | 7 | 6 | -14% |
| Поля в requests | 10 | 12 | +20% (но функциональность +100%) |
| Поля в logs | 7 | 5 | -29% |
| Общие поля | 35 | 33 | -6% |

## Функциональные улучшения

### 1. **JSON функциональность**
```sql
-- Подсчет элементов в заявке
SELECT json_array_length(items_json) as items_count FROM requests;

-- Поиск заявок с определенным картриджем
SELECT * FROM requests 
WHERE json_extract(items_json, '$[*].cartridge_type_id') LIKE '%1%';
```

### 2. **Автоматический SLA мониторинг**
```sql
-- Просмотр просроченных заявок
SELECT * FROM v_sla_monitoring WHERE sla_status = 'overdue';
```

### 3. **Аналитика**
```sql
-- Статистика по филиалам
SELECT * FROM v_request_stats;

-- Топ запрашиваемых картриджей
SELECT ct.name, SUM(json_extract(value, '$.quantity')) as total
FROM requests r
CROSS JOIN json_each(r.items_json)
JOIN cartridge_types ct ON json_extract(value, '$.cartridge_type_id') = ct.id
GROUP BY ct.id
ORDER BY total DESC;
```

## Преимущества для разработки

### 1. **Упрощение кода приложения**
- Меньше SQL запросов для создания заявки
- Нет необходимости в транзакциях для атомарности
- Проще валидация данных

### 2. **Лучшая производительность**
- Меньше JOIN'ов в запросах
- Оптимизированные индексы
- Представления для сложных запросов

### 3. **Автоматизация**
- Триггеры уменьшают количество ручных операций
- Автоматическое логирование
- Автоматическое создание связанных записей

### 4. **Масштабируемость**
- JSON позволяет добавлять новые поля без изменения схемы
- Представления изолируют сложную логику
- Индексы обеспечивают быстрый доступ к данным

## Рекомендации по использованию

1. **Для создания заявок:** Используйте JSON функции для работы с `items_json`
2. **Для отчетов:** Используйте готовые представления
3. **Для мониторинга:** Регулярно проверяйте `v_sla_monitoring`
4. **Для аналитики:** Используйте JSON функции для агрегации данных

## Миграция с исходной схемы

```sql
-- Создание новой таблицы requests с JSON
CREATE TABLE requests_new AS
SELECT 
  r.*,
  json_group_array(
    json_object(
      'cartridge_type_id', ri.cartridge_type_id,
      'quantity', ri.quantity
    )
  ) as items_json
FROM requests r
LEFT JOIN request_items ri ON r.id = ri.request_id
GROUP BY r.id;

-- Удаление старой таблицы request_items
DROP TABLE request_items;

-- Переименование новой таблицы
ALTER TABLE requests_new RENAME TO requests;
```

Эта улучшенная схема обеспечивает более компактный, функциональный и производительный код при сохранении всей функциональности исходной схемы.